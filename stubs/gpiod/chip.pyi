from collections.abc import Iterable
from datetime import timedelta
from types import TracebackType
from typing import Any

from .chip_info import ChipInfo
from .info_event import InfoEvent
from .line import Value
from .line_info import LineInfo
from .line_request import LineRequest
from .line_settings import LineSettings

__all__ = ["Chip"]

class Chip:
    def __init__(self, path: str) -> None: ...
    def __enter__(self) -> Chip: ...
    def __exit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: TracebackType | None,
    ) -> Any: ...
    def _check_closed(self) -> None: ...
    def close(self) -> None: ...
    def get_info(self) -> ChipInfo: ...
    def line_offset_from_id(self, id: str | int) -> int: ...
    def _get_line_info(self, line: int | str, watch: bool) -> LineInfo: ...
    def get_line_info(self, line: int | str) -> LineInfo: ...
    def watch_line_info(self, line: int | str) -> LineInfo: ...
    def unwatch_line_info(self, line: int | str) -> None: ...
    def wait_info_event(self, timeout: timedelta | float | None = None) -> bool: ...
    def read_info_event(self) -> InfoEvent: ...
    def _resolve_config_keys_to_offsets(
        self,
        config_keys: Iterable[Iterable[int | str] | int | str],
    ) -> list[int]: ...
    def request_lines(
        self,
        config: dict[Iterable[int | str] | int | str, LineSettings | None],
        consumer: str | None = None,
        event_buffer_size: int | None = None,
        output_values: dict[int | str, Value] | None = None,
    ) -> LineRequest: ...
    def fileno(self) -> int: ...
    @property
    def path(self) -> str: ...
    @property
    def fd(self) -> int: ...
